package fi.muni.cz.models;import static fi.muni.cz.models.testing.CustomMetrics.*;import fi.muni.cz.models.leastsquaresolver.Solver;import fi.muni.cz.models.leastsquaresolver.SolverResult;import java.text.DecimalFormat;import java.text.NumberFormat;import java.util.*;import org.apache.commons.math3.util.Pair;/** @author Radoslav Micko, 445611@muni.cz */public abstract class ModelAbstract implements Model {  protected Map<String, Double> modelParameters;  protected List<Pair<Integer, Integer>> trainingIssueData;  protected List<Pair<Integer, Integer>> testingIssueData;  protected Map<String, String> goodnessOfFit;  protected Map<String, String> predictiveAccuracy;  protected Solver solver;  private SolverResult solverResult;  /**   * Initialize model attributes.   *   * @param trainingIssueData list of cumulative issue data which model is fit to.   * @param testingIssueData list of cumulative issue data used to calculate predictive accuracy   * @param solver Solver to estimate model parameters.   */  public ModelAbstract(      List<Pair<Integer, Integer>> trainingIssueData,      List<Pair<Integer, Integer>> testingIssueData,      Solver solver) {    this.trainingIssueData = trainingIssueData;    this.testingIssueData = testingIssueData;    this.solver = solver;  }  @Override  public void estimateModelData(Integer decimalAmount) {    System.out.println("Evaluating " + getModelName());    calculateModelParameters();    calculateModelGoodnessOfFit(decimalAmount);    calculateModelPredictiveAccuracy(decimalAmount);  }  @Override  public List<Pair<Integer, Integer>> getIssuesPrediction(double howMuchToPredict) {    return calculateEstimatedIssuesOccurance(howMuchToPredict);  }  /** Calculate model parameters. */  protected void calculateModelParameters() {    solverResult = solver.optimize(getInitialParametersValue(), trainingIssueData);    if (solverResult.getParameters() != null) {      setParametersToMap(solverResult.getParameters());    }  }  private void calculateModelGoodnessOfFit(Integer decimalAmount) {    double alpha = 0.05;    Map<String, String> goodnessOfFitMap = new HashMap<>();    goodnessOfFitMap.put(        getModelName() + " AIC = ", convertResultToString(solverResult.getAic(), decimalAmount));    goodnessOfFitMap.put(        getModelName() + " BIC = ", convertResultToString(solverResult.getBic(), decimalAmount));    goodnessOfFitMap.put(        getModelName() + " Pseudo R2 = ",        convertResultToString(solverResult.getPseudoRSquared(), decimalAmount));    if (solverResult.getPseudoRSquared() == null) {      goodnessOfFitMap.put(getModelName() + " Pseudo R2 NHR = ", "Ignored");    }    if (solverResult.getPseudoRSquared() != null) {      goodnessOfFitMap.put(          getModelName() + " Pseudo R2 NHR = ",          1 - solverResult.getPseudoRSquared() > alpha ? "REJECT" : "NOT REJECT");    }    List<Pair<Integer, Integer>> trainingSetEstimates =        solverResult.getParameters() != null            ? calculateEstimatedIssuesOccurance(0)            : new ArrayList<>();    Double residualStandardError =        solverResult.getParameters() != null            ? calculateResidualStandardError(trainingIssueData, trainingSetEstimates)            : null;    Double meanSquaredError =        solverResult.getParameters() != null            ? calculateMeanSquaredError(trainingIssueData, trainingSetEstimates)            : null;    Double normalizedRootMeanSquaredError =        solverResult.getParameters() != null            ? calculateNormalizedRootMeanSquaredError(trainingIssueData, trainingSetEstimates)            : null;    Double predctiveAbility =        solverResult.getParameters() != null            ? calculateModelPredictiveAbility(trainingIssueData, trainingSetEstimates)            : null;    Double accuracyOfTheFinalPoint =        solverResult.getParameters() != null            ? calculateAccuracyOfTheFinalPoint(trainingIssueData, trainingSetEstimates)            : null;    goodnessOfFitMap.put(        getModelName() + " RSE = ", convertResultToString(residualStandardError, decimalAmount));    goodnessOfFitMap.put(        getModelName() + " MSE = ", convertResultToString(meanSquaredError, decimalAmount));    goodnessOfFitMap.put(        getModelName() + " NRMSE = ",        convertResultToString(normalizedRootMeanSquaredError, decimalAmount));    goodnessOfFitMap.put(        getModelName() + " PA = ", convertResultToString(predctiveAbility, decimalAmount));    goodnessOfFitMap.put(        getModelName() + " AOFP = ", convertResultToString(accuracyOfTheFinalPoint, decimalAmount));    goodnessOfFit = goodnessOfFitMap;  }  private void calculateModelPredictiveAccuracy(Integer decimalAmount) {    Map<String, String> predictiveAccuracyMap = new HashMap<>();    List<Pair<Integer, Integer>> testSetEstimates =        solverResult.getParameters() != null            ? calculateEstimatesForDataSet(testingIssueData)            : new ArrayList<>();    Double residualStandardError =        solverResult.getParameters() != null            ? calculateResidualStandardError(testingIssueData, testSetEstimates)            : null;    Double meanSquaredError =        solverResult.getParameters() != null            ? calculateMeanSquaredError(testingIssueData, testSetEstimates)            : null;    Double normalizedRootMeanSquaredError =        solverResult.getParameters() != null            ? calculateNormalizedRootMeanSquaredError(testingIssueData, testSetEstimates)            : null;    Double predctiveAbility =        solverResult.getParameters() != null            ? calculateModelPredictiveAbility(testingIssueData, testSetEstimates)            : null;    Double accuracyOfTheFinalPoint =        solverResult.getParameters() != null            ? calculateAccuracyOfTheFinalPoint(testingIssueData, testSetEstimates)            : null;    predictiveAccuracyMap.put(        getModelName() + " Pred. Acc. RSE = ",        convertResultToString(residualStandardError, decimalAmount));    predictiveAccuracyMap.put(        getModelName() + " Pred. Acc. MSE = ",        convertResultToString(meanSquaredError, decimalAmount));    predictiveAccuracyMap.put(        getModelName() + " Pred. Acc. NRMSE = ",        convertResultToString(normalizedRootMeanSquaredError, decimalAmount));    predictiveAccuracyMap.put(        getModelName() + " Pred. Acc. PA = ",        convertResultToString(predctiveAbility, decimalAmount));    predictiveAccuracyMap.put(        getModelName() + " Pred. Acc. AOFP = ",        convertResultToString(accuracyOfTheFinalPoint, decimalAmount));    predictiveAccuracy = predictiveAccuracyMap;  }  /**   * Calculate estimated and predicted issues.   *   * @param howMuchToPredict count of time unites to predict to future.   * @return Estimated issues occurance.   */  private List<Pair<Integer, Integer>> calculateEstimatedIssuesOccurance(double howMuchToPredict) {    List<Pair<Integer, Integer>> listOfEstimatedIssues =        calculateEstimatesForDataSet(trainingIssueData);    int last = trainingIssueData.get(trainingIssueData.size() - 1).getFirst();    for (int i = last + 1; i < last + howMuchToPredict; i++) {      double estimation = getFunctionValue(i);      Integer roundedEstimation = (int) estimation;      listOfEstimatedIssues.add(new Pair<>(i, roundedEstimation));    }    return listOfEstimatedIssues;  }  private List<Pair<Integer, Integer>> calculateEstimatesForDataSet(      List<Pair<Integer, Integer>> dataSet) {    List<Pair<Integer, Integer>> listOfEstimatedIssues = new ArrayList<>();    for (Pair<Integer, Integer> pair : dataSet) {      double estimation = getFunctionValue(pair.getFirst());      Integer roundedEstimation = (int) estimation;      listOfEstimatedIssues.add(          new Pair<>(pair.getFirst(), roundedEstimation == 0 ? 1 : roundedEstimation));    }    return listOfEstimatedIssues;  }  /**   * Get function value fo testPeriod.   *   * @param testPeriod i-th test period.   * @return value of function.   */  protected abstract double getFunctionValue(Integer testPeriod);  /**   * Set estimated parameters of model with name to set.   *   * @param params to be saved.   */  protected abstract void setParametersToMap(double[] params);  /**   * Get short name of Model.   *   * @return short name of model.   */  protected abstract String getModelShortName();  /**   * Get initial estimation of model parameters.   *   * @return initial parameters.   */  protected abstract int[] getInitialParametersValue();  @Override  public Map<String, String> getGoodnessOfFitData() {    return goodnessOfFit;  }  @Override  public Map<String, String> getPredictiveAccuracyData() {    return predictiveAccuracy;  }  @Override  public Map<String, Double> getModelParameters() {    return modelParameters;  }  @Override  public String getModelName() {    return getModelShortName();  }  private String convertResultToString(Double result, Integer decimals) {    NumberFormat decimalFormat = DecimalFormat.getInstance(Locale.US);    decimalFormat.setMaximumFractionDigits(decimals);    decimalFormat.setGroupingUsed(false);    if (result == null) {      return "Ignored";    }    return decimalFormat.format(result);  }}